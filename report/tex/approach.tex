\section{Proposed Approach}\label{sec:approach}


\begin{itemize}
	\item Lock-based implementation
	\item Lock-free implementation
	\item Correctness tests with applications
	\item Explain advantages vs disadvantages of approach
\end{itemize}

We decided to base the implementation of our concurrent priority queue on a lockfree Skiplist. A lockfree Skiplist is a good choice for a concurrent datastructure since the atomic operations are very local to 2-3 nodes and thereby the probabilty of conflicts between threads is minimized. Since our final goal was a port on to the Xeon Phi which comes with 60 cores this would be a good fit.\\
The Skiplist was implemented using C++ atomics and its {\em comapre\_and\_exchange} operation.\\
In Figure XX we have an illustration of Skiplist which essentially is a linked list with a hierarchial tree-like index structure. The index creation is probabilistic but should asymptotically lead to a structure which enables traversing to any node in $O(\log n)$.\\
MAYBE EXPLAIN some operations\\
Like most lockfree data structures we had to deal with the problem {\em predecessor-deletion} [FIND BETTER WORD, see paper]. The problem is explained in figure XX.
A common resolution is to add a delete flag to each node for lazy deletion. But this means it is necessary to do CAS operation on the {\em next} pointer and the delete flag simulatenously. Multiple options are possible: {\em Atomic Markable Reference}, Double CAS, double-width CAS, Transactional-Memory. For our implementation we used the first option and implemented a {\em Atomic Markable Reference} by using the least significant bit as a deletion flag. Thereby we are able to use the general {\em compare\_and\_exchange} operation in C++11. Since our next pointers are always alligned to 64bytes [what is the architecture doing??]. In general no issues should arise when using the least significant bit as a deletion flag.\\
Apart from the common Skiplist methods: empty(), size(), find(), remove(), insert(). We added a pop() method necessary for a priority queue and pop(k) and insert(k) for batch processing.\\


%MAYBE give complete API somewhere
\begin{lstlisting}[language=C++,basicstyle=\tt\footnotesize,captionpos=b,caption=PPQ interface,morekeywords={*, size_t}]
template <class T, class Comp> class PPQ
{
	bool empty() const;
	size_t size() const;
	bool push(const T& data);
	size_t push(T data[], int k);
	bool remove(const T& data);
	bool pop_front(T& data);
	size_t pop_front(T data[], int k);
	bool contains(T data);
	void print();
};
\end{lstlisting}

What about correctness verification...
