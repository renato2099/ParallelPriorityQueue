\section{Experimental Results}\label{sec:exp}

\begin{itemize}
	\item CPU results
		\begin{itemize}
			\item Insert-only workload
			\item Pop-only workload
			\item Mix workload
		\end{itemize}
	\item Xeon Phi results
		\begin{itemize}
			\item Insert-only workload
			\item Pop-only workload
			\item Mix workload
		\end{itemize}
	\item Explanation on why we are not fast
\end{itemize}

\mypar{Operational intensity}
% recap of operational intensity
Operational intensity is defined as the ratio of the number of instructions executed to the number of memory accesses(look for citation?). If there exist many instructions per memory access, then the program is considered to have a high computational intensity i.e. compute bounded. On the other hand, if there are a small number of instructions are executed per memory access, then the program is considered to have a low computational intensity i.e. memory bounded.
% why we think it matters in our case
Our project goal was to design a simple, yet effective, priority queue. Thus, we expected to have an operational intensity dominated mainly by the number of memory accesses, and aimed to improve this. Having to move data around has a different impact on CPU architectures. We will describe and explain how our data structure behaves on a MIC architecture (Intel XeonPhi co-processors) and on an Ivy Bridge processor (Intel Core i7 3770K).
% explain data + graph + core architecture
